介绍一篇[教程](http://blog.csdn.net/cutesource/article/details/5904501) 

##### 一、JVM的生命周期
- 1、JVM实例对应了一个独立运行的java程序，它是进程级别
    - a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点
    - b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程。
    - c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出

- 2、JVM执行引擎实例则对应了属于用户运行程序的线程，它是线程级别的


java中线程分为两种类型：**用户线程**和**守护线程**
- 1、 主线程结束后用户线程还会继续运行,JVM存活；主线程结束后守护线程和JVM的状态又下面第2条确定。
- 2、如果没有用户线程，都是守护线程，那么JVM结束（随之而来的是所有的一切烟消云散，包括所有的守护线程）。



补充说明：
- **定义**：守护线程--也称“服务线程”，在没有用户线程可服务时会自动离开。
- **优先级**：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。
- **设置**：通过Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。如果不设置次属性，默认为用户线程。必须在启动前设置；
- example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。
- **生命周期**：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。那Java的守护线程是什么样子的呢。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出。

##### 二、JVM的体系结构
- 1、类装载器（ClassLoader）（用来装载.class文件）
- 2、执行引擎（执行字节码，或者执行本地方法）
- 3、运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈）

##### 三、JVM中类的整个生命周期
加载＝》验证＝》准备＝》解析＝》初始化＝》使用＝》卸载 
- 1、加载
    
    类的加载阶段，主要是获取定义此类的二进制字节流，并将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，最后在Java堆中生成一个代表这个类的java.lang.Class对象作为方法区这些数据的访问入口。相对于类加载过程的其他阶段，加载阶段是开发期可控性最强的阶段。我们可以通过定制不通的类加载器，也就是ClassLoader来控制二进制字节流的获取方式。

- 2、验证

    验证，准备和解析其实都属于连接阶段，而验证就是连接阶段的第一步。这一阶段主要是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全。主要验证过程包括：文件格式验证，元数据验证，字节码验证以及符号引用验证。 

- 3、准备
    
    准备阶段正式为类变量分配内存并设置初始值。这里的初始值并不是初始化的值，而是数据类型的默认零值。这里提到的类变量是被static修饰的变量，而不是实例变量。关于准备阶段为类变量设置零值的唯一例外就是当这个类变量同时也被final修饰，那么在编译时，就会直接为这个常量赋上目标值。

- 4、解析
    
    解析时虚拟机将常量池中的符号引用替换为直接引用的过程。

- 5、初始化
    
    在准备阶段，变量已经赋过一次系统要求的初始值，在初始化阶段，则是根据程序员通过程序的主观计划区初始化类变量和其他资源。
    
    Java虚拟机规范规定了有4种情况必须立即对类进行初始化（加载，验证，准备必须在此之前完成） 
    
    - 1）当使用new关键字实例化对象时，当读取或者设置一个类的静态字段（被final修饰的除外）时，以及当调用一个类的静态方法时，如果类未初始化，则需先初始化。 
    - 2）通过反射机制对类进行调用时，如果类未初始化，则需先初始化。 
    - 3）当初始化一个类时，如果其父类未初始化，先初始化父类。 
    - 4）用户指定的执行主类（含main方法的那个类）在虚拟机启动时会先被初始化。

    除了上面这4种方式，所有引用类的方式都不会触发初始化，称为被动引用。如：通过子类引用父类的静态字段，不会导致子类初始化；通过数组定义来引用类，不会触发此类的初始化；引用类的静态常量不会触发定义常量的类的初始化，因为常量在编译阶段已经被放到常量池中了。
    

- 总结：在上述5个过程当中，验证，准备和解析完全由Java虚拟机主导和控制。只有加载阶段和初始化阶段程序员可以进行控制。在加载阶段可以通过实现自定义的ClassLoader来加载类的二进制流，在初始化阶段程序员则可完全按照需求来为类变量赋值。

**命令行执行java XXX.class的过程 ：**
找到JRE——》找到jvm.dll——》启动JVM并进行初始化——》产生Bootstrap Loader——》载入ExtClassLoader——》载入AppClassLoader——》执行java XXX.class

**JVM两种类装载器包括：**   
- 启动类装载器：是JVM实现的一部分；
- 用户自定义类装载器：则是Java程序的一部分，必须是ClassLoader类的子类。

装载器：    
- Bootstrap ClassLoader
    >这是JVM的根ClassLoader，它是用C++实现的，JVM启动时初始化此ClassLoader，并由此ClassLoader完成$JAVA_HOME中jre/lib/rt.jar（Sun JDK的实现）中所有class文件的加载，这个jar中包含了java规范定义的所有接口以及实现。
- Extension ClassLoader
    >JVM用此classloader来加载扩展功能的一些jar包。
- System ClassLoader
    >JVM用此classloader来加载启动参数中指定的Classpath中的jar包以及目录，在Sun JDK中ClassLoader对应的类名为AppClassLoader。
- User-Defined ClassLoader
    >User-DefinedClassLoader是Java开发人员继承ClassLoader抽象类自行实现的ClassLoader，基于自定义的ClassLoader可用于加载非Classpath中的jar以及目录。

JVM装载顺序： Jvm启动时，由Bootstrap向User-Defined方向加载类；; 应用进行ClassLoader时，由User-Defined向Bootstrap方向查找并加载类；

ClassLoader抽象类的几个关键方法：
- loadClass
>此方法负责加载指定名字的类，ClassLoader的实现方法为先从已经加载的类中寻找，如没有则继续从parent ClassLoader中寻找，如仍然没找到，则从System ClassLoader中寻找，最后再调用findClass方法来寻找，如要改变类的加载顺序，则可覆盖此方法
-findLoadedClass
>此方法负责从当前ClassLoader实例对象的缓存中寻找已加载的类，调用的为native的方法。
- findClass
>此方法直接抛出ClassNotFoundException，因此需要通过覆盖loadClass或此方法来以自定义的方式加载相应的类。
- findSystemClass
>此方法负责从System ClassLoader中寻找类，如未找到，则继续从Bootstrap ClassLoader中寻找，如仍然为找到，则返回null。
- defineClass
>此方法负责将二进制的字节码转换为Class对象
- resolveClass
>此方法负责完成Class对象的链接，如已链接过，则会直接返回。

##### 四、JVM执行引擎
在执行方法时JVM提供了四种指令来执行：
- （1）invokestatic：调用类的static方法
- （2）invokevirtual：调用对象实例的方法
- （3）invokeinterface：将属性定义为接口来进行调用
- （4）invokespecial：JVM对于初始化对象（Java构造器的方法为：<init>）以及调用对象实例中的私有方法时。


##### 五、JVM运行时数据区
- 第一块：PC寄存器
>PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。
- 第二块：JVM栈
>JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址
- 第三块：堆（Heap）

    它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。

    - （1）       堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的
    - （2）       Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配
    - （3）       TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。

- 第四块：方法区域（Method Area）

    - （1）在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。
    - （2）方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class 对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。

- 第五块：运行时常量池（Runtime Constant Pool）
>存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。
- 第六块：本地方法堆栈（Native Method Stacks）
>JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。

##### 六、JVM垃圾回收
**GC的基本原理**：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停

- （1）对新生代的对象的收集称为minor GC；
- （2）对旧生代的对象的收集称为Full GC；
- （3）程序中主动调用System.gc()强制执行的GC为Full GC。

不同的对象引用类型， GC会采用不同的方法进行回收，**JVM对象的引用分为了四种类型**：
- （1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）
- （2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）
- （3）弱引用：在GC时一定会被GC回收
- （4）虚引用：由于虚引用只是用来得知对象是否被GC